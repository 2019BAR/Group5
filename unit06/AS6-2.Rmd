---
title: "AS6-2"
author: "Allen Lin"
date: "2019/3/29 test"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)

```


```{r}

Waits <- faithful$waiting / 10

summary(Waits)

# Frame
par(cex = 0.7)
plot(0,0,xlim=c(4,10),ylim=c(0,1.1),xlab="噴發時間(分鐘)", 
     ylab="密度 or (累計)機率", main="分布、機率與密度", family="STKaiti")
abline(h=1, col='lightgray', lwd=0.25, lty=2)


# Empirical PDF
rug(Waits)
# Empirical CDF
plot(ecdf(Waits), cex=0, verticals=T, lwd=2, col='darkgray', add=T)
## add = T 會將該圖層加在原先的圖上 , 不會額外再重新繪圖


# Histogram PDF
Bins = 20                             # no. bins
bx = seq(min(Waits), max(Waits), length= (Bins+1) ) # break sequence 
hist(Waits, col="#B3FFFF7F", border="white", ylim=c(0,1.1),
     freq=F, breaks=bx, add=T)
abline(h=0, col='lightgray', lwd=0.25)
# Histogram CDF
adj = (bx[2] - bx[1])/2
steps = stepfun(bx-adj, c(0, sapply(bx, function(b) mean(Waits <= b))))
plot(steps, cex=0, col='#33CC337F', lwd=3, lty=1, add=T)

# Smooth PDF
Adjust = 1    # bandwidth adjustment
DEN = density(Waits, adjust = Adjust)
lines(DEN, col='gold', lwd=3)
# Smooth CDF
PDF = approxfun(DEN$x, DEN$y, yleft=0, yright=0)
x = seq(4,10,1)
y = sapply(x, function(i) integrate(PDF, -Inf, i)$value)
lines(x, y, col='red', lwd=3, lty=2) 

# Mark Range
x1 = 8; x2 = 9
rect(x1,-0.1,x2,1.2,col= rgb(0,1,0,alpha=0.2),border=NA)
# x = seq(x1, x2, length=100)
# polygon(c(x, x2, x1),  c(PDF(x), 0, 0), col="#FF99003F", border=NA)
# Calculate Probability
(integrate(PDF, x1, x2)$value)


###############################
rbinom(1000000, 1000, 0.2) %>% hist(breaks=100,freq=F)
curve(dnorm(x,mean=200,sd=sqrt(160)), col='red', lwd=2, add=T)


```


####【A.選擇方法】
##### ■ 我們為甚麼需要隨機變數？ 什麼時候我們需要用到隨機變數？
因為實際生活中的存在許多不穩定的因素，隨機變數有助於我們做決策。
有了隨機變數的概念，才能夠量化抽樣的成果並進一步進行模型建構與預測。
##### ■ 隨機變數沒有固定的值，那我們要如何做計算呢？
利用機率分布的概念計算。
##### ■ 我們可以用直方圖或數值標記來估計噴發時間落在某一區間的機率嗎？

可以。

##### ■ 直方圖(histogram)也可以當作一種模型嗎？ 數值標記(rug)呢？

皆可以。
前者以一定的區間 (binwidth) 為單位，去預估落點；
後者則是以標記的方式，在量夠大的時候形成曲線

##### ■ 直方圖和平滑模型哪一個比較適合用來表示噴發時間的分布？ 為甚麼？

##### ■ 用數值標記來預測噴發時間會比用直方圖「準」嗎？ 「準」是什麼意思呢？

#####  

####【B.調整參數】調整一下模型參數的滑桿 …
##### ■ 你覺得最合適的直方圖欄數(support/binwidth)是？ 為甚麼？


##### ■ 最合適的平滑模型頻寬(bandwidth)呢？



##### ■ 調高欄寬和頻寬會讓模型變複雜，還是變簡單呢？



##### ■ 模型越複雜，它跟實際值之間的誤差是越大、還是越小？



##### ■ 那麼，越複雜的模型就會越準，對嗎？



#####  

####【C.建立模型、估計機率】
##### 請從課堂筆記的程式碼找出來 … 
##### ■ 從變數向量(D)求出機率密度曲線(DEN)
##### ■ 將機率密度曲線(DEN)轉換成機率密度函數(PDF)
##### ■ 對機率密度函數(PDF)做積分，算出機率(PROB)
#####  
##### 這三行程式，然後…
##### ■ 將頻寬調整參數(adjust)設為1，算出「等待時間」落在80到90之間的機率

0.268507

##### ■ 將頻寬調整參數設為0.5，算出等待時間落在80到90之間的機率

0.282745

##### ■ 算出來的機率比較高的就是比較好的模型，對嗎？ 為甚麼？

不對，我們不應該用機率來評估一個模型的好壞，
而是應該用「複雜度」來看他。

#####  

####【D.預測與決策】
##### 假設有一個賭局，你可以花30元選定一個連續60秒的時段，如果老忠實下一次的噴發時間落在你指定的區間，你就可以贏到100元；請你使用頻寬為0.5的平滑密度模型 …
##### ■ 決定要不要參加這個賭局
要
##### ■ 如果你參加的話，你要把噴發時間設定在哪一個區間呢？

3.8 ~ 4.8 mins

##### ■ 你設在這個區間的話，參加這個賭局的期望值是？

(0.48 * 70) + (0.52 * (-30))
18 塊錢

#####  
##### 假如賭場老闆從零開始把每10秒鐘設為一個區間，每個區間的賭金是五塊錢 …
##### ■ 你要怎麼押注，才能獲得最高的期望值呢？

押其中的吧幹

##### ■ 你的賭金和期望值各是多少？



#####  
##### 將獲利的期望值和賭金的比值稱為「期望投資報酬率」 …
##### ■ 「最大期望投資報酬率」和「最大期望報酬」的投資策略是一樣的嗎？
##### ■ 你認為哪一個策略目標比較好呢？ 為什麼？


### Faithful - eruptions 程式碼
```{r}

D = faithful$eruptions  # copy to a short name

# Frame
par(cex = 0.7)
plot(0,0,xlim=c(1.5,5.25),ylim=c(0,1.1),xlab="噴發時間(分鐘)", 
     ylab="密度 or (累計)機率", main="分布、機率與密度")
abline(h=1, col='lightgray', lwd=0.5, lty=2)

# Empirical PDF
rug(D)
# Empirical CDF
plot(ecdf(D), cex=0, verticals=T, lwd=2, col='darkgray', add=T)
## add = T 會將該圖層加在原先的圖上 , 不會額外再重新繪圖

# Histogram PDF
Bins = 20                             # no. bins
bx = seq(min(D), max(D), length= (Bins+1) ) # break sequence 
hist(D, col="#B3FFFF7F", border="white", ylim=c(0,1.1),
     freq=F, breaks=bx, add=T)
abline(h=0, col='lightgray', lwd=0.25)
# Histogram CDF
adj = (bx[2] - bx[1])/2
steps = stepfun(bx-adj, c(0, sapply(bx, function(b) mean(D <= b))))
plot(steps, cex=0, col='#33CC337F', lwd=3, lty=1, add=T)

# Smooth PDF
Adjust = 0.5    # bandwidth adjustment
DEN = density(D, adjust = Adjust)
lines(DEN, col='gold', lwd=3)
# Smooth CDF
PDF = approxfun(DEN$x, DEN$y, yleft=0, yright=0)
x = seq(1,6,0.1)
y = sapply(x, function(i) integrate(PDF, -Inf, i)$value)
lines(x, y, col='red', lwd=3, lty=2) 
```


```{r}
# Mark Range

EveryProb <- rep(0,31)
names(EveryProb) <- seq(1,6,(1/6))
j <- 1
for ( i in seq(1,6,(1/6)) ) {
  EveryProb[j] <- integrate(PDF, i, (i+(1/6)))$value
  j <- j + 1
}
EveryProb

EveryProb <- sort(EveryProb, decreasing = T)

E <- rep(0,31)
names(E) <- c(1:31)
for ( i in 1:31 ) {
  
  E[i] <- ( 100 * (sum(EveryProb[1:i])) ) - ( 5*i )
  
}
E
max(E)
EveryProb[1:9]


###############################
# rbinom(1000000, 1000, 0.2) %>% hist(breaks=100,freq=F)
# curve(dnorm(x,mean=200,sd=sqrt(160)), col='red', lwd=2, add=T)



```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
